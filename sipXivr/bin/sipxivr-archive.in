#!/bin/env ruby

# Copyright (c) 2012 eZuce, Inc. All rights reserved.
# Contributed to SIPfoundry under a Contributor Agreement
#
# This software is free software; you can redistribute it and/or modify it under
# the terms of the Affero General Public License (AGPL) as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# This software is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
# details.

#
# Archive and Restore sipXconfig's postgres database. Can be used as standalone
# script or within the larger sipx-backup context.
#

require 'fileutils'

class ArchiveBase
  attr_writer :verbose

  def initialize
    @initd = "@SIPX_SERVICEDIR@"
    @sipxdata = "@SIPX_VARDIR@"
    @bin_dir = '@SIPX_BINDIR@'
    @backup_dir = '@SIPX_VARDIR@/backup'
    @backup_tmp_dir = '@SIPX_TMPDIR@/backup'
    @restore_dir = '@SIPX_TMPDIR@/restore'
    @confdir = "@SIPX_CONFDIR@"
    @mongo_client_ini = "#{@confdir}/mongo-client.ini"
    @ver = "@PACKAGE_VERSION@"
    @mongo_properties = {}
    IO.foreach("#{@mongo_client_ini}") do |line|
    @mongo_properties[$1.strip] = $2 if line =~ /([^=]*)=(.*)\/\/(.*)/ || line =~ /([^=]*)=(.*)/
    end
  end

  def cmd(cmd)
    puts cmd if @verbose
    rc = system(cmd)
    return rc
  end
end

class Backup < ArchiveBase
  def run(params)
    File.open("#{@backup_tmp_dir}/version",'w') { |f|
      f.puts @ver
    }

    cmd "mongodump --out #{@backup_tmp_dir}/dump --db vmdb -h #{@mongo_properties['connectionString']}" or
      raise "Could not backup voicemail gridfs database"
    cmd "tar -cz -f #{params[:file]} -C #{@backup_tmp_dir} version dump/ #{@sipxdata}/mediaserver/data" or
      raise "Unabled to archive voicemail #{params[:file]}"

    #Clean temp files
    FileUtils.rm_rf(["#{@backup_tmp_dir}/version", "#{@backup_tmp_dir}/dump"])
  end
end

class Restore < ArchiveBase
  def initialize
    super
  end

  def run(params)
    cmd "tar -tzf #{params[:file]} version" or
      raise "Verification failed. Could not determine format of #{params[:file]}"    

    cmd "#{@initd}/sipxivr stop" if params[:restart]

    cmd "tar -xz --exclude=version --exclude=dump -C #{@sipxdata}/../.. -f #{params[:file]}" or
      raise "Failed to extract database from archive."

    cmd "chown @SIPXPBXUSER@:@SIPXPBXGROUP@ -R #{@sipxdata}/mediaserver/data" or
      raise "Failed to set permissions on mailstore dir."

    cmd "tar -zxvf #{params[:file]} -C #{@backup_tmp_dir} dump" or
      raise "Failed to extract voicemail database from archive"
    
    cmd "mongo vmdb --eval \"db.voicemail.files.remove({})\" --host #{@mongo_properties['connectionString']}"
    cmd "mongo vmdb --eval \"db.voicemail.chunks.remove({})\" --host #{@mongo_properties['connectionString']}"
    cmd "mongo vmdb --eval \"db.voicemail.metadata.remove({})\" --host #{@mongo_properties['connectionString']}"
    
    Dir.foreach("#{@backup_tmp_dir}/dump/vmdb") do |fname|
      cmd "mongorestore --db vmdb #{@backup_tmp_dir}/dump/vmdb/#{fname} --host #{@mongo_properties['connectionString']}" or 
        raise "Failed to restore voicemail dump"
    end

    #Clean temp files
    FileUtils.rm_rf(["#{@backup_tmp_dir}/version", "#{@backup_tmp_dir}/dump"])

    cmd "#{@initd}/sipxivr start" if params[:restart]
  end
end

if __FILE__ == $0

require 'optparse'
params = {}
operation = nil
params[:ipaddress] = `hostname -i`.chomp
params[:restart] = true
params[:dryrun] = false
params[:crack_pin_len] = 4
verbose = false
args = OptionParser.new { |opts|
  opts.banner = <<EOF
Create or restore configuration to/from an archive file.
EOF

  opts.on("--backup <archive>",
      "Backup to the specified file.") { |v|
    operation = Backup.new
    params[:file] = v
  }

  opts.on("--restore <archive>",
      "Restore from the specified file.") { |v|
    operation = Restore.new
    params[:file] = v
  }

  opts.on("--verbose", "Show each command that is run.") {
    verbose = true
  }

  opts.separator ""
  opts.separator "Restore options:"

  opts.on_tail("--no-restart",
      "Use this flag if sipxconfig is already stopped and you do not want this script to re-stop \
or start sipxconfig after it's done."){
    params[:restart] = false
  }
}
args.parse!

if operation.nil?
  raise "Must specify either restore or archive options."
end

operation.verbose = verbose
operation.run(params)
exit 0

end
